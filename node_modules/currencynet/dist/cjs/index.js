#! /usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const helpers_1 = require("./helpers");
const { Command } = require("commander");
const figlet = require("figlet");
const fs = require("fs");
const path = require("path");
const { exec } = require("child_process");
const program = new Command();
const mainscript = process.argv[1];
const mainscriptDir = path.dirname(mainscript);
console.log(figlet.textSync("NPM OFFLINE SAVER"));
program
    .name('NPMSO (Install Npm package offline')
    .version((0, helpers_1.getVersion)())
    .description("A package to store npm package offline")
    .option("-l, --ls", "List all packages offline")
    .option("-i, --install", "Install a package(s)")
    .option("-s, --save  <value...>", "Install a package(s) for offline use")
    .option("-u, --use <value...>", "Install a offline package to a specific node project directory")
    .option("-up, --update <value...>", "Update a specific package or all package")
    .parse(process.argv);
const options = program.opts();
// console.log(options, process.argv, mainscriptDir)
if (options.ls) {
    (0, helpers_1.listDirContents)(`${mainscriptDir}/../node_modules`);
}
if (options.save) {
    const packages = options.save;
    // const commands = `npm install ${package_} --prefix ${filepath} && npm i ${package_}`
    let commands = `npm install ${packages.join(" ")} --prefix ${mainscriptDir}/../`;
    if (options.install)
        commands += ` && npm i ${packages.join(" ")}`;
    console.log('npms > ' + commands);
    exec(commands, (err, stdout, stderr) => {
        if (err)
            return console.log(err);
        console.log(stdout);
    });
}
// add the following code
if (options.use) {
    try {
        //  && npm cache clean --force
        if (!fs.existsSync(`${process.cwd()}/package.json`))
            throw new Error('No package.json file found in the directory');
        const packages = options.use;
        (0, helpers_1.PrepPackages)(packages)
            .then(packagesAndDep => {
            console.log(packagesAndDep);
            const commands = `npm i ${packagesAndDep.join(" ")}`;
            console.log(commands);
            return commands;
        })
            .then(commands => exec(`${commands}`, (err, stdout, stderr) => {
            if (err)
                return console.log(err);
            console.log(stdout);
            console.log("packages, ===> ", packages);
            const packageJson = (0, helpers_1.changeVersion)(packages);
            fs.writeFileSync(`${process.cwd()}/package.json`, JSON.stringify(packageJson, null, 2));
        })).catch(err => console.log(err));
    }
    catch (error) {
        console.log(error);
    }
}
if (options.touch) {
    (0, helpers_1.createFile)(path.resolve(__dirname, options.touch));
}
if (!process.argv.slice(2).length) {
    program.outputHelp();
}
//# sourceMappingURL=index.js.map